import json
import os
import requests
from LanguageModel import LanguageModel
import telebot
import random
from utils import parse_username

""" A telegram bot intended to be used in a group chat. The bot will generate text based on the previous messages in the chat, and send it as a message.
The bot might also send a sticker as a reply to a message in the future.
"""

class Chatroom:
    def __init__(self, chat_id, chat_name):
        """ A class containing information about some chatsrooms last messages etc.
        """
        self.chat_id = chat_id
        self.chat_name = chat_name
        self.last_messages = []
        

class FinGPTelebot:
    def __init__(self, model_name, token, n_messages = 10, simulate_users = True):
        self.model_name = model_name
        self.token = token
        self.n_messages = n_messages
        self.simulate_users = simulate_users
        self.last_messages = {}
        self.pre_prompt = "GPT on hauska ja vitsikäs Teekkari-botti;\n"
        self.bot = telebot.TeleBot(self.token)
        self.lm = LanguageModel(self.model_name)
        print("Bot initialized")

    def parse_username(self, username):
        try:
            return parse_username(username)
        except TypeError:
            return "Anonym"

    def run(self):
        self.bot.infinity_polling()
    
    def give_info(self, chat_id):
        self.bot.send_message(chat_id,"""Olen suomenkieliseen mini GPT3 malliin pohjautuva botti.
                              Näen viimeisimmät viestit siitä lähtien kun liityn keskusteluun, ja sen jälkeen yritän laitella hauskoja viestejä.""")

    def store_sticker(self, message):
        """ Store the sent stickers"""
        uname = self.parse_username(message.from_user.username)
        self.last_messages.setdefault(message.chat.id,[]).append((uname, message.sticker.emoji))
        print(uname, message.sticker.emoji)
        
    def pre_fill_messages(self, messages, chat_id):
        """ Fill last_messages with messages messages (list of tuples (username, message))"""
        self.last_messages[chat_id] = messages
        
    def store_file(self, message):
        uname = self.parse_username(message.from_user.username)
        self.last_messages.setdefault(message.chat.id,[]).append((uname, message.document.file_name))
        print(uname, message.document.file_name)

    def store_message(self, message):
        if len(self.last_messages.setdefault(message.chat.id,[])) >= self.n_messages:
            self.last_messages[message.chat.id].pop(0)
        with open("running_chat_history.json", "a", encoding="utf-8") as f:
            # Write the time, chat, username and message to file
            msg = {"time": message.date, "chat": message.chat.id, "username": message.from_user.username, "message": message.text}
            f.write(json.dumps(msg) + "\n")
        uname = self.parse_username(message.from_user.username)
        text = str(message.text)
        # Check if simulated user
        if self.simulate_users and ": " in text:
            uname, text = text.split(": ", 1)
        text = text.replace("\n", " ")
        print(uname, text)
        self.last_messages.setdefault(message.chat.id,[]).append((uname, text))

    def parse_reply(self, reply):
        """ This method is used to parse a continuation generated by the model.
        This returns the first sentence of the continuation plus the consecutive lines that start with "GPT:"
        """
        reply = reply.split("\n")
        parsed_reply = [reply[0]]
        for line in reply[1:]:
            if line.startswith("GPT:") and line[4] != "n":
                parsed_reply.append(line.replace("GPT:", ""))
            else:
                break
        return parsed_reply
    
    def send_reply(self, chat_id):
        if len(self.last_messages.setdefault(chat_id,[])) < 1:
            return
        #print("Sending reply ----------------------------------------")
        #Format "<username>: <message>\n<username>: <message>\nGPT:"
        prompt = "".join([f"{username}:{message}\n" for username, message in self.last_messages.setdefault(chat_id,[])]) + "GPT:"
        prompt = self.pre_prompt + prompt
        print(f"Received prompt\n---------------------------------------\n{prompt}\n---------------------------------------")
        model_reply = ""
        model_reply = self.lm.get_only_new_tokens(prompt, temperature=0.6, max_new_tokens=100)
        print(f"Full reply\n---------------------------------------\n{model_reply}\n---------------------------------------")
        if not model_reply:
            print(f"No reply generated")
            return
        # We possible have multiple replies, since the model might continue the conversation by sending multiple messages
        model_reply = self.parse_reply(model_reply)
        print(f"Sending reply\n---------------------------------------")
        for line in model_reply:
            print(line)
            try:
                self.bot.send_message(chat_id, line,timeout=10)
                self.last_messages.setdefault(chat_id,[]).append(("GPT", line))
            except requests.exceptions.ReadTimeout:
                print(f"Timed out while sending message {line}")
                break
        print("---------------------------------------")

    
